<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Decentralized Chat â€” Web UI (Signed)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; max-width:900px; margin:18px auto; padding:0 12px; }
    header { display:flex; gap:12px; align-items:center; }
    #messages { border:1px solid #ddd; height:360px; overflow:auto; padding:8px; background:#fafafa; margin-top:12px; }
    .msg { padding:8px; border-bottom:1px solid #eee; }
    .meta { font-size:0.82em; color:#666; margin-top:6px; }
    .controls { margin-top:10px; display:flex; gap:8px; align-items:center; }
    input[type=text], input[type=search] { padding:8px; font-size:1rem; }
    button { padding:8px 12px; font-size:0.95rem; cursor:pointer; }
    .small { font-size:0.85rem; color:#444; }
    .ok { color: green; }
    .err { color: red; }
    .mine { background:#eef9ff; }
    .signed-badge { padding:2px 6px; border-radius:4px; background:#e6ffed; color:#1a7f37; font-weight:600; margin-left:8px; font-size:0.8rem; }
    #topbar { display:flex; gap:12px; align-items:center; margin-top:8px; flex-wrap:wrap; }
  </style>
</head>
<body>
  <header>
    <h2 style="margin:0">Decentralized Chat</h2>
    <div style="margin-left:auto" class="small">WebSocket + On-chain anchoring + MetaMask signing</div>
  </header>

  <div id="topbar">
    <label class="small">Name: <input id="name" type="text" value="webuser" /></label>
    <label class="small">Address: <input id="addr" type="text" placeholder="0x..." style="width:320px" /></label>
    <button id="connectBtn">Connect</button>
    <span id="status" class="small">Disconnected</span>
    <label class="small" style="margin-left:12px"><input id="useMeta" type="checkbox" /> Use MetaMask to sign</label>
    <button id="mmConnect" title="Connect MetaMask" style="margin-left:8px">Connect MetaMask</button>
  </div>

  <div id="messages" aria-live="polite"></div>

  <div class="controls">
    <input id="text" type="text" placeholder="Type message" style="flex:1" />
    <button id="sendBtn">Send</button>
    <button id="storeBtn">Store last hash on-chain</button>
    <span id="storeResult" class="small"></span>
  </div>

  <script>
    // Config (same-origin server)
    const WS_URL = 'ws://localhost:9002/ws';
    const STORE_URL = '/store';
    const HISTORY_URL = '/history';

    // state
    let ws = null;
    let lastHash = null;
    let myName = null;
    let localAddr = null;
    // lastSigned: { hash: '0x...', sig: '0x...', addr: '0x...' }
    window.lastSigned = null;

    // UTIL
    function escapeHtml(s) {
      return String(s || '').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    }
    function appendMessage(content, metaText, isMine=false) {
      const el = document.createElement('div');
      el.className = 'msg' + (isMine ? ' mine' : '');
      el.innerHTML = `<div>${escapeHtml(content)}</div>${metaText ? `<div class="meta">${escapeHtml(metaText)}</div>` : ''}`;
      document.getElementById('messages').appendChild(el);
      document.getElementById('messages').scrollTop = document.getElementById('messages').scrollHeight;
    }

    // crypto.subtle SHA-256 -> hex (no 0x)
    async function sha256hex_async(msg) {
      const enc = new TextEncoder();
      const data = enc.encode(msg);
      const buf = await crypto.subtle.digest('SHA-256', data);
      return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // MetaMask helpers
    async function isMetaMaskAvailable() {
      return !!window.ethereum;
    }
    async function mm_request_accounts() {
      if (!window.ethereum) throw new Error('MetaMask not found');
      return await window.ethereum.request({ method: 'eth_requestAccounts' });
    }
    async function getMetaMaskAccount() {
      const accounts = await mm_request_accounts();
      return accounts[0];
    }
    async function metamask_sign_hash(hashHex, account) {
      // personal_sign expects [message, account]
      // Many dapps pass the raw message; here we pass the 0x... hash string to match server's expectation.
      return await window.ethereum.request({
        method: 'personal_sign',
        params: [hashHex, account]
      });
    }

    // Load recent history from server
    async function loadHistory(limit=200) {
      try {
        const res = await fetch(HISTORY_URL + '?limit=' + limit);
        if (!res.ok) { console.warn('History fetch failed', res.status); return; }
        const j = await res.json();
        const msgs = j.messages || [];
        for (const m of msgs) {
          const signerInfo = m.signer ? ` | signer: ${m.signer}` : '';
          const meta = `${m.from || 'unknown'} @ ${new Date(m.ts*1000).toLocaleString()} | hash: ${m.hash || ''}${signerInfo}`;
          const isMine = (m.from === localAddr) || (m.signer && localAddr && m.signer.toLowerCase() === localAddr.toLowerCase());
          appendMessage(m.text || '', meta, isMine);
        }
      } catch (e) {
        console.warn('Failed to load history', e);
      }
    }

    // WebSocket connect + handlers
    async function connectWS(name, addr) {
      if (ws && ws.readyState === WebSocket.OPEN) ws.close();
      ws = new WebSocket(WS_URL);

      ws.addEventListener('open', async () => {
        document.getElementById('status').innerText = 'Connected';
        appendMessage(`Connected as ${name} (${addr || 'no-addr'})`);
        ws.send(JSON.stringify({ type: 'register', name, addr }));
        await loadHistory(200);
      });

      ws.addEventListener('message', (ev) => {
        try {
          const data = JSON.parse(ev.data);
          if (data.type === 'broadcast') {
            const signerInfo = data.signer ? ` | signer: ${data.signer}` : '';
            const meta = `${data.from || 'unknown'} @ ${new Date(data.ts*1000).toLocaleString()} | hash: ${data.hash || ''}${signerInfo}`;
            const isMine = (data.from === localAddr) || (data.signer && localAddr && data.signer.toLowerCase() === localAddr.toLowerCase());
            appendMessage(data.text || '', meta, isMine);
            lastHash = data.hash || lastHash;
          } else if (data.type === 'peer-joined') {
            appendMessage(`Peer joined: ${data.name || data.addr}`, '');
          } else {
            appendMessage('Server: ' + ev.data, '');
          }
        } catch (e) {
          appendMessage('Invalid msg: ' + ev.data, '');
        }
      });

      ws.addEventListener('close', () => {
        document.getElementById('status').innerText = 'Disconnected';
        appendMessage('Disconnected from server');
      });

      ws.addEventListener('error', (e) => {
        appendMessage('WebSocket error', '');
        console.error('WS error', e);
      });
    }

    // wire up connect button
    document.getElementById('connectBtn').addEventListener('click', async () => {
      myName = document.getElementById('name').value || 'webuser';
      localAddr = document.getElementById('addr').value || '';
      await connectWS(myName, localAddr);
    });

    // Connect MetaMask button: autofill address input
    document.getElementById('mmConnect').addEventListener('click', async () => {
      if (!await isMetaMaskAvailable()) { alert('MetaMask not found'); return; }
      try {
        const acct = await getMetaMaskAccount();
        document.getElementById('addr').value = acct;
        appendMessage('MetaMask connected: ' + acct, '');
      } catch (e) {
        appendMessage('MetaMask connection cancelled or failed: ' + e.message, '');
      }
    });

    // Send message flow: compute hash, optionally sign, send via WS
    async function sendMessageFromUI() {
      if (!ws || ws.readyState !== WebSocket.OPEN) { alert('Connect first'); return; }
      const txt = document.getElementById('text').value;
      if (!txt) return;
      const addrInput = document.getElementById('addr').value || '';
      const ts = Math.floor(Date.now() / 1000);
      const hex = await sha256hex_async(txt + ts.toString());
      const hashWith0x = '0x' + hex;

      let sig = null;
      let signerAddr = null;
      if (document.getElementById('useMeta').checked && window.ethereum) {
        try {
          signerAddr = await getMetaMaskAccount();
          sig = await metamask_sign_hash(hashWith0x, signerAddr);
          // store lastSigned for later store operation
          window.lastSigned = { hash: hashWith0x, sig: sig, addr: signerAddr };
        } catch (e) {
          console.warn('MetaMask sign failed or cancelled:', e);
          sig = null;
          window.lastSigned = null;
        }
      } else {
        // clear lastSigned if not using MetaMask
        window.lastSigned = null;
      }

      const payload = {
        type: 'chat',
        room: 'lobby',
        from: addrInput || signerAddr || 'webclient',
        ts,
        text: txt,
        hash: hashWith0x,
        sig: sig
      };

      // send over websocket
      ws.send(JSON.stringify(payload));

      const meta = `${payload.from} @ ${new Date(ts*1000).toLocaleString()} ${sig ? '| signed' : ''} | hash: ${hashWith0x}`;
      appendMessage(txt, meta, (payload.from && payload.from === localAddr));
      lastHash = hashWith0x;
      document.getElementById('text').value = '';
      document.getElementById('storeResult').innerText = '';
    }

    document.getElementById('sendBtn').addEventListener('click', sendMessageFromUI);
    document.getElementById('text').addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessageFromUI(); });

    // Store button: call /store; include signature if lastSigned matches the lastHash
    document.getElementById('storeBtn').addEventListener('click', async () => {
      if (!lastHash) { alert('No last hash available'); return; }
      document.getElementById('storeResult').innerText = 'Storing...';
      try {
        const body = { hash: lastHash, sender: document.getElementById('addr').value || null };
        // include sig when present and matches the same hash
        if (window.lastSigned && window.lastSigned.hash === lastHash && window.lastSigned.sig) {
          body.sig = window.lastSigned.sig;
          body.sender = window.lastSigned.addr || body.sender;
        }
        const resp = await fetch(STORE_URL, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(body)
        });
        const j = await resp.json();
        if (resp.ok) {
          document.getElementById('storeResult').innerHTML = `<span class="ok">Stored tx: ${escapeHtml(j.txHash)} (block ${escapeHtml(String(j.blockNumber))})</span>`;
        } else {
          document.getElementById('storeResult').innerHTML = `<span class="err">Error: ${escapeHtml(j.error || JSON.stringify(j))}</span>`;
        }
      } catch (e) {
        document.getElementById('storeResult').innerHTML = `<span class="err">Network error: ${escapeHtml(e.message || e)}</span>`;
      }
    });

    // Optional: auto-connect on load (commented out). Uncomment to auto-connect.
    // window.addEventListener('load', () => connectWS(document.getElementById('name').value, document.getElementById('addr').value));
  </script>
</body>
</html>
